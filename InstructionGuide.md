# 指令详解

下面将详细介绍mas汇编指令。

- [指令详解](#指令详解)
  - [注释](#注释)
  - [标签](#标签)
  - [cmd](#cmd)
  - [mov](#mov)
  - [set](#set)
  - [load](#load)
  - [store](#store)
  - [cmp](#cmp)
  - [cmpin](#cmpin)
  - [b](#b)
  - [bi](#bi)
  - [bn](#bn)
  - [calc](#calc)
  - [rand](#rand)
  - [call](#call)
  - [debug](#debug)
  - [log](#log)

## 注释

在任意行不在字符串内的`#`后的任何文本将被编译器忽略。
例如下面的都是合法的汇编代码
```
# *********** 代码开始 *************
debug "hello #### world"     # 这里无论你写什么都会被忽略，除了换行
```

## 标签

每个标签下的指令都会被编译为一个单独mcfunction文件。
例如`hey:`、`114514_Labels:`、`__1919810aaaa:`。可以以数字开头，但其中必须只包含字母、数字和下划线。

## cmd

直接执行minecraft命令，但必须用引号包含。

```
cmd "say hello there"     # 直接执行`say hello there`
```

## mov

将寄存器src的值复制到dst。

```
mov R1 R0                 # 将R0的值复制到R1
```

## set

为一个寄存器赋值

```
set R0 12345              # 将12345赋值给寄存器R0
```

## load

将内存中的值读取到寄存器R0

```
load 20                   # 将内存中下标为20的数据读取到寄存器R0
```

## store

将寄存器R0的值读取到内存中

```
store 30                  # 将寄存器R0的值读取到下标为30的内存中
```

## cmp

将寄存器R0和R1的值进行比较，将结果存储到R0中
比较符有`<`、`>`、`<=`、`>=`、`==`、`!=`

```
cmp ==                    # 如果寄存器R0和R1的值相等，则在R0存储1，否则存储0
cmp <                     # 如果寄存器R0的值小于R1的，则在R0存储1，否则存储0
```

## cmpin

将寄存器R0的值和固定表达式进行匹配，将结果存储到R0中。可以添加`not`标识符来反转结果。

```
cmpin -5..10             # 如果R0的值为-5、10或其之间任何值，则在R0存储1，否则存储0
cmpin not -5..10         # 如果R0的值不为-5、10或其之间任何值，则在R0存储1，否则存储0
cmpin 20                 # 如果R0的值为20，则在R0存储1，否则存储0
cmpin not 20             # 如果R0的值不为20，则在R0存储1，否则存储0
```

## b

branch。直接跳转到标签，在标签运行结束后返回。后台会直接编译为function指令。

```
b my_label               # 跳转到my_label
```

## bi

branch if。当寄存器R0值不为0时跳转到标签。

## bn

branch if not。当寄存器R0值为0时跳转到标签。

## calc

将R0和R1的值进行计算，R0为被操作数，R1为操作数。可使用的计算符有

- `+`：相加
- `-`：相减
- `*`：相乘
- `/`：相除
- `%`：求余数
- `<`：取最小值
- `>`：取最大值

```
calc /                   # 将R0除以R1的值放在R0
calc <                   # 将R0和R1中取最小值放在R0
```

## rand

将R0设置为在一定范围内的随机值

```
rand -24 98             # 从-24和98和其之间随机选择一个整数赋值到R0
```

## call

将以执行函数的形式跳转到标签。该操作将会使store、load和swap取址偏移给定值，在call指令执行完毕后会恢复偏移值。

```
__main__:
set R0 5
store 1                 # 在实际地址1存储5
call 1 plus10           # 将偏移地址+1，调用plus10
                        # 偏移地址恢复
set R0 23
store 2                 # 在实际地址2存储23
call 2 plus10           # 将偏移地址+2，调用plus10
                        # 偏移地址恢复

load 1                  # 加载15到R0
mov R1 R0               # 复制15到R1
load 2                  # 加载33到R0
add                     # 相加

store 0                 # 此刻实际地址0的值为48

plus10:
set R1 10               # 将10赋值给R1
load 0                  # 第一次被调用时，将从实际地址1中读取值到R0
                        # 第二次被调用时，将从实际地址2中读取值到R0
add
store 0                 # 把+10后的值放回原位
```

## debug

打印当前汇编行数，并显示帮助信息

```
__main__:
debug "hello world"     # 显示 “(at: 2) hello world”
```

## log

直接打印信息，相当于minecraft say指令

```
log "hello world"      # 显示 “hello world”
```